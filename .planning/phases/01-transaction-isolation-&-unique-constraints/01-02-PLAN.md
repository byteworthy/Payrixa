---
phase: 01-transaction-isolation-&-unique-constraints
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - upstream/models.py
  - upstream/migrations/0014_add_unique_constraint_driftevent_phase1.py
  - upstream/migrations/0015_add_unique_constraint_driftevent_phase2.py
autonomous: true

must_haves:
  truths:
    - "Database rejects duplicate DriftEvent records for same (customer, report_run, payer, cpt_group, drift_type)"
    - "Unique constraint migrations can be applied without table locks"
    - "Existing data does not violate the new constraint"
    - "Constraint is enforced at database level, not just application level"
  artifacts:
    - path: "upstream/models.py"
      provides: "DriftEvent model with UniqueConstraint in Meta.constraints"
      contains: "driftevent_unique_signal"
    - path: "upstream/migrations/0014_add_unique_constraint_driftevent_phase1.py"
      provides: "Phase 1 migration - concurrent index creation"
      contains: "AddIndexConcurrently"
    - path: "upstream/migrations/0015_add_unique_constraint_driftevent_phase2.py"
      provides: "Phase 2 migration - constraint from existing index"
      contains: "SeparateDatabaseAndState"
  key_links:
    - from: "upstream/migrations/0015_add_unique_constraint_driftevent_phase2.py"
      to: "upstream/models.py"
      via: "UniqueConstraint synchronization"
      pattern: "UNIQUE USING INDEX"
---

<objective>
Implement unique constraints on DriftEvent using three-phase zero-downtime migrations.

Purpose: Prevent duplicate DriftEvent records at the database level, ensuring data integrity even if application-level locking is bypassed. Uses PostgreSQL's concurrent index creation to avoid table locks during migration.

Output: DriftEvent model with UniqueConstraint and two migrations implementing the three-phase pattern (index creation + constraint attachment).
</objective>

<execution_context>
@/home/codespace/.claude/get-shit-done/workflows/execute-plan.md
@/home/codespace/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-transaction-isolation-&-unique-constraints/01-RESEARCH.md

# Key source files
@upstream/models.py
@upstream/migrations/0013_claimvalidationhistory_cvh_error_count_nonnegative_and_more.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Phase 1 migration - concurrent unique index</name>
  <files>upstream/migrations/0014_add_unique_constraint_driftevent_phase1.py</files>
  <action>
Create the first migration that adds a unique index concurrently (without locking the table).

Create file: `upstream/migrations/0014_add_unique_constraint_driftevent_phase1.py`

```python
"""
Phase 1 of 2: Add unique index concurrently for DriftEvent.

This migration creates a unique index using PostgreSQL's CONCURRENTLY option,
which allows the index to be built without blocking reads or writes to the table.

Part of DB-02: Implement unique constraints for data integrity.
"""
from django.contrib.postgres.operations import AddIndexConcurrently
from django.db import migrations, models


class Migration(migrations.Migration):
    """
    Zero-downtime migration: Creates unique index concurrently.

    IMPORTANT: atomic = False is required for CONCURRENTLY operations.
    PostgreSQL cannot run CREATE INDEX CONCURRENTLY inside a transaction.
    """

    atomic = False  # Required for AddIndexConcurrently

    dependencies = [
        ("upstream", "0013_claimvalidationhistory_cvh_error_count_nonnegative_and_more"),
    ]

    operations = [
        # Create unique index concurrently (no table lock)
        # Index name follows pattern: {table}_{columns}_uniq_idx
        AddIndexConcurrently(
            model_name="driftevent",
            index=models.Index(
                fields=["customer", "report_run", "payer", "cpt_group", "drift_type"],
                name="driftevent_signal_uniq_idx",
            ),
        ),
    ]
```

Key points:
- `atomic = False` is required for CONCURRENTLY operations
- Uses AddIndexConcurrently from django.contrib.postgres.operations
- Index name must be unique and descriptive
- This index will be converted to a constraint in phase 2
  </action>
  <verify>
Verify migration file syntax: `python manage.py check`
Preview migration: `python manage.py showmigrations upstream`
  </verify>
  <done>
Migration 0014 creates unique index concurrently without table locks.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Phase 2 migration - attach constraint to index</name>
  <files>upstream/migrations/0015_add_unique_constraint_driftevent_phase2.py</files>
  <action>
Create the second migration that converts the index to a unique constraint.

Create file: `upstream/migrations/0015_add_unique_constraint_driftevent_phase2.py`

```python
"""
Phase 2 of 2: Convert index to unique constraint for DriftEvent.

This migration uses SeparateDatabaseAndState to:
1. Update Django's model state with the UniqueConstraint
2. Use PostgreSQL's "UNIQUE USING INDEX" to attach constraint to existing index

The existing index from phase 1 is promoted to a constraint, which is a fast
metadata-only operation that doesn't rebuild the index.

Part of DB-02: Implement unique constraints for data integrity.
"""
from django.db import migrations, models


class Migration(migrations.Migration):
    """
    Zero-downtime migration: Converts existing index to constraint.

    Uses SeparateDatabaseAndState to keep Django's model state in sync
    with the actual database schema while using PostgreSQL-specific SQL.
    """

    dependencies = [
        ("upstream", "0014_add_unique_constraint_driftevent_phase1"),
    ]

    operations = [
        migrations.SeparateDatabaseAndState(
            state_operations=[
                # Update Django's internal state to know about the constraint
                migrations.AddConstraint(
                    model_name="driftevent",
                    constraint=models.UniqueConstraint(
                        fields=["customer", "report_run", "payer", "cpt_group", "drift_type"],
                        name="driftevent_unique_signal",
                    ),
                ),
            ],
            database_operations=[
                # Use existing index to create constraint (fast metadata operation)
                # PostgreSQL's "UNIQUE USING INDEX" promotes an existing unique index
                # to a constraint without rebuilding it
                migrations.RunSQL(
                    sql="""
                        ALTER TABLE upstream_driftevent
                        ADD CONSTRAINT driftevent_unique_signal
                        UNIQUE USING INDEX driftevent_signal_uniq_idx;
                    """,
                    reverse_sql="""
                        ALTER TABLE upstream_driftevent
                        DROP CONSTRAINT IF EXISTS driftevent_unique_signal;
                        -- Note: Index is automatically dropped when constraint is dropped
                        -- if it was created from the index. We recreate it for rollback.
                        CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS driftevent_signal_uniq_idx
                        ON upstream_driftevent (customer_id, report_run_id, payer, cpt_group, drift_type);
                    """,
                ),
            ],
        ),
    ]
```

Key points:
- SeparateDatabaseAndState keeps Django state and database in sync
- Uses "UNIQUE USING INDEX" which is a fast metadata operation
- Reverse SQL handles rollback by recreating the index
- Constraint name differs from index name (index will be renamed/absorbed)
  </action>
  <verify>
Verify migration file syntax: `python manage.py check`
Preview migration SQL: `python manage.py sqlmigrate upstream 0015`
  </verify>
  <done>
Migration 0015 converts index to unique constraint using SeparateDatabaseAndState.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add UniqueConstraint to DriftEvent model</name>
  <files>upstream/models.py</files>
  <action>
Update the DriftEvent model class to include the UniqueConstraint in its Meta.constraints.

In upstream/models.py, locate the DriftEvent class and update its Meta.constraints list:

```python
class DriftEvent(models.Model):
    # ... existing fields ...

    class Meta:
        constraints = [
            # CHECK constraints for data integrity (Phase 3 Task #3)
            models.CheckConstraint(
                check=models.Q(severity__gte=0.0) & models.Q(severity__lte=1.0),
                name="drift_severity_range",
            ),
            models.CheckConstraint(
                check=models.Q(confidence__gte=0.0) & models.Q(confidence__lte=1.0),
                name="drift_confidence_range",
            ),
            models.CheckConstraint(
                check=models.Q(statistical_significance__gte=0.0)
                & models.Q(statistical_significance__lte=1.0)
                | models.Q(statistical_significance__isnull=True),
                name="drift_significance_range",
            ),
            # DB-02: Unique constraint prevents duplicate drift signals
            # Each (customer, report_run, payer, cpt_group, drift_type) combination
            # can only have one DriftEvent record
            models.UniqueConstraint(
                fields=["customer", "report_run", "payer", "cpt_group", "drift_type"],
                name="driftevent_unique_signal",
            ),
        ]
        indexes = [
            # ... existing indexes unchanged ...
        ]
```

Add the UniqueConstraint AFTER the existing CheckConstraints in the constraints list. The name MUST match the constraint name used in migration 0015 ("driftevent_unique_signal").

Why this matters:
- Keeps Django's model definition in sync with database schema
- Allows Django to validate uniqueness before hitting the database
- Documents the constraint for developers reading the model
  </action>
  <verify>
Verify model is valid: `python manage.py check`
Verify constraint is recognized: `python manage.py makemigrations --dry-run upstream` (should show "No changes detected" since migration already handles it)
  </verify>
  <done>
DriftEvent model has UniqueConstraint on (customer, report_run, payer, cpt_group, drift_type).
  </done>
</task>

</tasks>

<verification>
1. Django check passes: `python manage.py check`
2. Migrations are recognized: `python manage.py showmigrations upstream`
3. Migration SQL is valid: `python manage.py sqlmigrate upstream 0014 && python manage.py sqlmigrate upstream 0015`
4. Dry run shows no additional changes needed: `python manage.py makemigrations --dry-run upstream`
5. Apply migrations (if using test database): `python manage.py migrate upstream`
6. Verify constraint exists in database:
   ```sql
   SELECT conname, contype FROM pg_constraint WHERE conname = 'driftevent_unique_signal';
   ```
7. All existing drift tests still pass: `python manage.py test upstream.tests.DriftEventTests -v 2`
</verification>

<success_criteria>
- Migration 0014 creates unique index concurrently (atomic=False, AddIndexConcurrently)
- Migration 0015 converts index to constraint (SeparateDatabaseAndState, UNIQUE USING INDEX)
- DriftEvent model includes UniqueConstraint with name "driftevent_unique_signal"
- Migrations can be applied and rolled back without errors
- Constraint prevents duplicate records at database level
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-transaction-isolation-&-unique-constraints/01-02-SUMMARY.md`
</output>
