---
phase: 05-performance-testing-and-rollback-fix
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/test_rollback.py
  - .github/workflows/deploy.yml
autonomous: true

must_haves:
  truths:
    - "Rollback test simulates deployment failure and validates recovery"
    - "Test verifies application returns to healthy state after rollback"
    - "Rollback test runs as part of deployment workflow"
    - "Health check validates application functionality post-rollback"
  artifacts:
    - path: "scripts/test_rollback.py"
      provides: "Deployment rollback test script"
      min_lines: 80
    - path: ".github/workflows/deploy.yml"
      provides: "Deploy workflow with rollback test step"
      contains: "test_rollback"
  key_links:
    - from: "scripts/test_rollback.py"
      to: "/api/v1/health/"
      via: "HTTP health check"
      pattern: "requests\\.get.*health"
    - from: ".github/workflows/deploy.yml"
      to: "scripts/test_rollback.py"
      via: "python command"
      pattern: "python.*test_rollback"
---

<objective>
Create deployment rollback test and integrate into deploy workflow

Purpose: Validate that deployment failures trigger automatic rollback and application recovers to healthy state
Output: Rollback test script and updated deploy workflow with rollback validation
</objective>

<execution_context>
@/home/codespace/.claude/get-shit-done/workflows/execute-plan.md
@/home/codespace/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.github/workflows/deploy.yml (existing deploy workflow)
@scripts/smoke_test.py (reference for health check patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create deployment rollback test script</name>
  <files>scripts/test_rollback.py</files>
  <action>
Create a rollback test script that validates deployment recovery:

1. **Script structure with argparse:**
   ```python
   #!/usr/bin/env python3
   """
   Deployment Rollback Test

   Validates that the deployment system can recover from failures:
   1. Checks current deployment is healthy
   2. Simulates a failed deployment scenario
   3. Verifies rollback triggers (or manual rollback succeeds)
   4. Confirms application returns to healthy state

   Usage:
     python scripts/test_rollback.py --url https://staging.example.com
     python scripts/test_rollback.py --url http://localhost:8000 --local
   """
   ```

2. **Health check function:**
   - `check_health(url: str, timeout: int = 10) -> tuple[bool, dict]`
   - Makes GET request to `/api/v1/health/`
   - Returns (is_healthy: bool, response_data: dict)
   - Handles connection errors gracefully

3. **Version check function:**
   - `get_version(url: str) -> str | None`
   - Extracts version from health endpoint response
   - Returns None if unavailable

4. **Rollback validation function:**
   - `validate_rollback(url: str, expected_version: str | None = None) -> bool`
   - Checks health endpoint returns 200
   - Optionally verifies version matches expected
   - Returns True if application is healthy

5. **Main test flow:**
   ```python
   def run_rollback_test(url: str, local: bool = False) -> bool:
       """
       Run the rollback validation test.

       For local testing:
         - Checks application is healthy (simulates "pre-deployment" state)
         - Since no actual deployment happens, validates health check works

       For CI/staging:
         - Records initial version
         - Waits for deployment workflow to complete
         - Verifies health check passes (deployment or rollback succeeded)
       """
   ```

6. **Exit codes:**
   - 0: Rollback test passed (application healthy)
   - 1: Health check failed (application unhealthy)
   - 2: Configuration error (bad URL, etc.)

7. **Command line arguments:**
   - `--url`: Base URL of application (required)
   - `--local`: Run in local mode (skip deployment simulation)
   - `--timeout`: Health check timeout in seconds (default: 30)
   - `--retries`: Number of health check retries (default: 3)
   - `--retry-delay`: Delay between retries in seconds (default: 10)

8. **Logging:**
   - Use print statements with clear status indicators
   - Show [PASS], [FAIL], [INFO] prefixes
   - Log all health check attempts

Note: This is a validation test, not an actual rollback trigger. It confirms the deployment system (Kubernetes, Cloud Run, etc.) can recover. In local/CI mode, it validates the health check mechanism works correctly.
  </action>
  <verify>
Run: `python scripts/test_rollback.py --help` shows usage information
Run: `python scripts/test_rollback.py --url http://localhost:8000 --local --timeout 5` (may fail if server not running, but script should execute)
  </verify>
  <done>
Rollback test script exists with health check validation, configurable URL, retries, and clear exit codes
  </done>
</task>

<task type="auto">
  <name>Task 2: Add rollback test to deploy workflow</name>
  <files>.github/workflows/deploy.yml</files>
  <action>
Update the deploy workflow to include rollback validation:

1. **Add rollback test step after smoke tests:**
   ```yaml
   - name: Run rollback validation test
     if: vars.DEPLOYMENT_URL != ''
     run: |
       pip install requests
       python scripts/test_rollback.py \
         --url "${{ vars.DEPLOYMENT_URL }}" \
         --timeout 60 \
         --retries 5 \
         --retry-delay 15
     env:
       DEPLOYMENT_URL: ${{ vars.DEPLOYMENT_URL }}
   ```

2. **Add local rollback test job for PR validation:**
   Add a new job that runs for PRs to validate the rollback script works:
   ```yaml
   validate-rollback-script:
     runs-on: ubuntu-latest
     if: github.event_name == 'pull_request'

     steps:
     - name: Checkout code
       uses: actions/checkout@v4

     - name: Set up Python
       uses: actions/setup-python@v5
       with:
         python-version: '3.12'

     - name: Install dependencies
       run: |
         pip install requests

     - name: Validate rollback script syntax
       run: |
         python -m py_compile scripts/test_rollback.py
         python scripts/test_rollback.py --help
   ```

3. **Update the main deploy job to include rollback validation step** (after the existing smoke test step)

4. **Add failure notification context:**
   If rollback test fails, the workflow should clearly indicate this in the logs

Note: Keep the existing workflow structure intact. Only add the new steps/jobs without removing existing functionality.
  </action>
  <verify>
Run: `python -c "import yaml; y=yaml.safe_load(open('.github/workflows/deploy.yml')); print('Deploy workflow valid')"`
Run: `grep -c "test_rollback" .github/workflows/deploy.yml` returns at least 1
  </verify>
  <done>
Deploy workflow includes rollback test step that validates application health after deployment
  </done>
</task>

<task type="auto">
  <name>Task 3: Create rollback test for CI environment</name>
  <files>upstream/tests_rollback.py</files>
  <action>
Create a pytest-compatible rollback test that can run in CI without deployment:

1. **Test file structure:**
   ```python
   """
   Rollback Test Suite

   Tests the deployment rollback validation script works correctly.
   These tests run locally against the Django test server.
   """
   import subprocess
   import sys
   from pathlib import Path

   import pytest
   from django.test import LiveServerTestCase


   class RollbackScriptTests(LiveServerTestCase):
       """Tests for the rollback validation script."""

       def test_rollback_script_syntax(self):
           """Test that rollback script has valid Python syntax."""
           result = subprocess.run(
               [sys.executable, "-m", "py_compile", "scripts/test_rollback.py"],
               capture_output=True,
               text=True,
           )
           self.assertEqual(result.returncode, 0, f"Syntax error: {result.stderr}")

       def test_rollback_script_help(self):
           """Test that rollback script shows help."""
           result = subprocess.run(
               [sys.executable, "scripts/test_rollback.py", "--help"],
               capture_output=True,
               text=True,
           )
           self.assertEqual(result.returncode, 0)
           self.assertIn("--url", result.stdout)

       def test_rollback_local_mode_healthy(self):
           """Test rollback script passes with healthy server."""
           # LiveServerTestCase provides self.live_server_url
           result = subprocess.run(
               [
                   sys.executable,
                   "scripts/test_rollback.py",
                   "--url", self.live_server_url,
                   "--local",
                   "--timeout", "10",
                   "--retries", "1",
               ],
               capture_output=True,
               text=True,
           )
           # Should pass since health endpoint is available
           self.assertEqual(
               result.returncode, 0,
               f"Rollback test failed: stdout={result.stdout}, stderr={result.stderr}"
           )

       def test_rollback_invalid_url_fails(self):
           """Test rollback script fails with invalid URL."""
           result = subprocess.run(
               [
                   sys.executable,
                   "scripts/test_rollback.py",
                   "--url", "http://localhost:99999",
                   "--local",
                   "--timeout", "2",
                   "--retries", "1",
               ],
               capture_output=True,
               text=True,
           )
           # Should fail since nothing is running on port 99999
           self.assertNotEqual(result.returncode, 0)
   ```

2. **Key test cases:**
   - Script syntax is valid Python
   - Help output shows expected arguments
   - Local mode passes with healthy server (uses LiveServerTestCase)
   - Invalid URL results in failure exit code

3. **Note:** Uses Django's LiveServerTestCase to spin up a test server, so health endpoint is available
  </action>
  <verify>
Run: `python manage.py test upstream.tests_rollback --verbosity=2` (may need server running)
Run: `python -c "from upstream.tests_rollback import RollbackScriptTests; print('Test module imports OK')"`
  </verify>
  <done>
Pytest-compatible rollback tests exist that validate the rollback script against live server
  </done>
</task>

</tasks>

<verification>
1. `python scripts/test_rollback.py --help` shows usage with --url, --local, --timeout, --retries options
2. `python -m py_compile scripts/test_rollback.py` exits with code 0
3. `grep "test_rollback" .github/workflows/deploy.yml` shows script is referenced
4. `python -c "import yaml; yaml.safe_load(open('.github/workflows/deploy.yml'))"` validates YAML
5. `python -c "from upstream.tests_rollback import RollbackScriptTests"` imports successfully
</verification>

<success_criteria>
- Rollback test script exists with:
  - Health check validation
  - Configurable URL, timeout, retries
  - Clear exit codes (0=pass, 1=fail, 2=config error)
  - Local mode for CI testing
- Deploy workflow includes rollback test step
- PR validation job checks rollback script syntax
- Pytest tests validate rollback script works against live server
</success_criteria>

<output>
After completion, create `.planning/phases/05-performance-testing-and-rollback-fix/05-02-SUMMARY.md`
</output>
